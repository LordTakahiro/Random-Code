// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_addons_tile_FlxCaveGenerator
#include <flixel/addons/tile/FlxCaveGenerator.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRandom
#include <flixel/math/FlxRandom.h>
#endif

namespace flixel{
namespace addons{
namespace tile{

void FlxCaveGenerator_obj::__construct() { }

Dynamic FlxCaveGenerator_obj::__CreateEmpty() { return new FlxCaveGenerator_obj; }

hx::ObjectPtr< FlxCaveGenerator_obj > FlxCaveGenerator_obj::__new()
{
	hx::ObjectPtr< FlxCaveGenerator_obj > _hx_result = new FlxCaveGenerator_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic FlxCaveGenerator_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxCaveGenerator_obj > _hx_result = new FlxCaveGenerator_obj();
	_hx_result->__construct();
	return _hx_result;
}

::String FlxCaveGenerator_obj::convertMatrixToString(::Array< ::Dynamic> Matrix){
            	HX_STACK_FRAME("flixel.addons.tile.FlxCaveGenerator","convertMatrixToString",0x80e5f51d,"flixel.addons.tile.FlxCaveGenerator.convertMatrixToString","flixel/addons/tile/FlxCaveGenerator.hx",20,0xd1f97ff2)
            	HX_STACK_ARG(Matrix,"Matrix")
HXLINE(  21)		HX_VARI( ::String,mapString) = HX_("",00,00,00,00);
HXLINE(  23)		{
HXLINE(  23)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  23)			HX_VARI( Int,_g) = Matrix->length;
HXDLIN(  23)			while((_g1 < _g)){
HXLINE(  23)				HX_VARI( Int,y) = _g1++;
HXLINE(  25)				{
HXLINE(  25)					HX_VARI( Int,_g3) = (int)0;
HXDLIN(  25)					HX_VARI( Int,_g2) = Matrix->__get(y).StaticCast< ::Array< Int > >()->length;
HXDLIN(  25)					while((_g3 < _g2)){
HXLINE(  25)						HX_VARI( Int,x) = _g3++;
HXLINE(  27)						Int _hx_tmp = Matrix->__get(y).StaticCast< ::Array< Int > >()->__get(x);
HXDLIN(  27)						::String _hx_tmp1 = ::Std_obj::string(_hx_tmp);
HXDLIN(  27)						hx::AddEq(mapString,(_hx_tmp1 + HX_(",",2c,00,00,00)));
            					}
            				}
HXLINE(  30)				hx::AddEq(mapString,HX_("\n",0a,00,00,00));
            			}
            		}
HXLINE(  33)		return mapString;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxCaveGenerator_obj,convertMatrixToString,return )

::Array< ::Dynamic> FlxCaveGenerator_obj::generateCaveMatrix(Int Columns,Int Rows,hx::Null< Int >  __o_SmoothingIterations,hx::Null< Float >  __o_WallRatio){
Int SmoothingIterations = __o_SmoothingIterations.Default(6);
Float WallRatio = __o_WallRatio.Default(((Float)0.5));
            	HX_STACK_FRAME("flixel.addons.tile.FlxCaveGenerator","generateCaveMatrix",0xc1ccff26,"flixel.addons.tile.FlxCaveGenerator.generateCaveMatrix","flixel/addons/tile/FlxCaveGenerator.hx",46,0xd1f97ff2)
            	HX_STACK_ARG(Columns,"Columns")
            	HX_STACK_ARG(Rows,"Rows")
            	HX_STACK_ARG(SmoothingIterations,"SmoothingIterations")
            	HX_STACK_ARG(WallRatio,"WallRatio")
HXLINE(  48)		HX_VARI( ::Array< ::Dynamic>,matrix) = ::flixel::addons::tile::FlxCaveGenerator_obj::generateInitialMatrix(Columns,Rows);
HXLINE(  50)		{
HXLINE(  50)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  50)			while((_g1 < Rows)){
HXLINE(  50)				HX_VARI( Int,y) = _g1++;
HXLINE(  52)				{
HXLINE(  52)					HX_VARI( Int,_g3) = (int)0;
HXDLIN(  52)					while((_g3 < Columns)){
HXLINE(  52)						HX_VARI( Int,x) = _g3++;
HXLINE(  54)						::Array< Int > _hx_tmp = matrix->__get(y).StaticCast< ::Array< Int > >();
HXDLIN(  54)						Int _hx_tmp1;
HXDLIN(  54)						Float _hx_tmp2 = ::flixel::FlxG_obj::random->_hx_float(null(),null(),null());
HXDLIN(  54)						if ((_hx_tmp2 < WallRatio)) {
HXLINE(  54)							_hx_tmp1 = (int)1;
            						}
            						else {
HXLINE(  54)							_hx_tmp1 = (int)0;
            						}
HXDLIN(  54)						_hx_tmp[x] = _hx_tmp1;
            					}
            				}
            			}
            		}
HXLINE(  59)		HX_VARI( ::Array< ::Dynamic>,matrix2) = ::flixel::addons::tile::FlxCaveGenerator_obj::generateInitialMatrix(Columns,Rows);
HXLINE(  62)		{
HXLINE(  62)			HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN(  62)			while((_g11 < SmoothingIterations)){
HXLINE(  62)				++_g11;
HXLINE(  64)				::flixel::addons::tile::FlxCaveGenerator_obj::runCelluarAutomata(matrix,matrix2);
HXLINE(  67)				HX_VARI( ::Array< ::Dynamic>,temp) = matrix;
HXLINE(  68)				matrix = matrix2;
HXLINE(  69)				matrix2 = temp;
            			}
            		}
HXLINE(  72)		return matrix;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxCaveGenerator_obj,generateCaveMatrix,return )

::String FlxCaveGenerator_obj::generateCaveString(Int Columns,Int Rows,hx::Null< Int >  __o_SmoothingIterations,hx::Null< Float >  __o_WallRatio){
Int SmoothingIterations = __o_SmoothingIterations.Default(6);
Float WallRatio = __o_WallRatio.Default(((Float)0.5));
            	HX_STACK_FRAME("flixel.addons.tile.FlxCaveGenerator","generateCaveString",0x1734f1b6,"flixel.addons.tile.FlxCaveGenerator.generateCaveString","flixel/addons/tile/FlxCaveGenerator.hx",87,0xd1f97ff2)
            	HX_STACK_ARG(Columns,"Columns")
            	HX_STACK_ARG(Rows,"Rows")
            	HX_STACK_ARG(SmoothingIterations,"SmoothingIterations")
            	HX_STACK_ARG(WallRatio,"WallRatio")
HXLINE(  87)		::Array< ::Dynamic> _hx_tmp = ::flixel::addons::tile::FlxCaveGenerator_obj::generateCaveMatrix(Columns,Rows,SmoothingIterations,WallRatio);
HXDLIN(  87)		return ::flixel::addons::tile::FlxCaveGenerator_obj::convertMatrixToString(_hx_tmp);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxCaveGenerator_obj,generateCaveString,return )

::Array< ::Dynamic> FlxCaveGenerator_obj::generateInitialMatrix(Int Columns,Int Rows){
            	HX_STACK_FRAME("flixel.addons.tile.FlxCaveGenerator","generateInitialMatrix",0x1b8c5d2d,"flixel.addons.tile.FlxCaveGenerator.generateInitialMatrix","flixel/addons/tile/FlxCaveGenerator.hx",98,0xd1f97ff2)
            	HX_STACK_ARG(Columns,"Columns")
            	HX_STACK_ARG(Rows,"Rows")
HXLINE(  99)		HX_VARI( ::Array< ::Dynamic>,matrix) = ::Array_obj< ::Dynamic>::__new();
HXLINE( 101)		{
HXLINE( 101)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 101)			while((_g1 < Rows)){
HXLINE( 101)				HX_VARI( Int,y) = _g1++;
HXLINE( 103)				matrix->push(::Array_obj< Int >::__new());
HXLINE( 105)				{
HXLINE( 105)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 105)					while((_g3 < Columns)){
HXLINE( 105)						++_g3;
HXLINE( 107)						matrix->__get(y).StaticCast< ::Array< Int > >()->push((int)0);
            					}
            				}
            			}
            		}
HXLINE( 111)		return matrix;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxCaveGenerator_obj,generateInitialMatrix,return )

Int FlxCaveGenerator_obj::countNumWallsNeighbors(::Array< ::Dynamic> Matrix,Int PosX,Int PosY,hx::Null< Int >  __o_Distance){
Int Distance = __o_Distance.Default(1);
            	HX_STACK_FRAME("flixel.addons.tile.FlxCaveGenerator","countNumWallsNeighbors",0xd76bda92,"flixel.addons.tile.FlxCaveGenerator.countNumWallsNeighbors","flixel/addons/tile/FlxCaveGenerator.hx",122,0xd1f97ff2)
            	HX_STACK_ARG(Matrix,"Matrix")
            	HX_STACK_ARG(PosX,"PosX")
            	HX_STACK_ARG(PosY,"PosY")
            	HX_STACK_ARG(Distance,"Distance")
HXLINE( 123)		HX_VARI( Int,count) = (int)0;
HXLINE( 124)		HX_VARI( Int,rows) = Matrix->length;
HXLINE( 125)		HX_VARI( Int,columns) = Matrix->__get((int)0).StaticCast< ::Array< Int > >()->length;
HXLINE( 127)		{
HXLINE( 127)			HX_VARI( Int,_g1) = -(Distance);
HXDLIN( 127)			HX_VARI( Int,_g) = (Distance + (int)1);
HXDLIN( 127)			while((_g1 < _g)){
HXLINE( 127)				HX_VARI( Int,y) = _g1++;
HXLINE( 129)				{
HXLINE( 129)					HX_VARI( Int,_g3) = -(Distance);
HXDLIN( 129)					HX_VARI( Int,_g2) = (Distance + (int)1);
HXDLIN( 129)					while((_g3 < _g2)){
HXLINE( 129)						HX_VARI( Int,x) = _g3++;
HXLINE( 132)						Bool _hx_tmp;
HXDLIN( 132)						Bool _hx_tmp1;
HXDLIN( 132)						Bool _hx_tmp2;
HXDLIN( 132)						if (((PosX + x) >= (int)0)) {
HXLINE( 132)							_hx_tmp2 = ((PosX + x) > (columns - (int)1));
            						}
            						else {
HXLINE( 132)							_hx_tmp2 = true;
            						}
HXDLIN( 132)						if (!(_hx_tmp2)) {
HXLINE( 132)							_hx_tmp1 = ((PosY + y) < (int)0);
            						}
            						else {
HXLINE( 132)							_hx_tmp1 = true;
            						}
HXDLIN( 132)						if (!(_hx_tmp1)) {
HXLINE( 132)							_hx_tmp = ((PosY + y) > (rows - (int)1));
            						}
            						else {
HXLINE( 132)							_hx_tmp = true;
            						}
HXDLIN( 132)						if (_hx_tmp) {
HXLINE( 134)							continue;
            						}
HXLINE( 138)						if ((Matrix->__get((PosY + y)).StaticCast< ::Array< Int > >()->__get((PosX + x)) != (int)0)) {
HXLINE( 140)							++count;
            						}
            					}
            				}
            			}
            		}
HXLINE( 145)		return count;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxCaveGenerator_obj,countNumWallsNeighbors,return )

void FlxCaveGenerator_obj::runCelluarAutomata(::Array< ::Dynamic> InMatrix,::Array< ::Dynamic> OutMatrix){
            	HX_STACK_FRAME("flixel.addons.tile.FlxCaveGenerator","runCelluarAutomata",0xfdcf422c,"flixel.addons.tile.FlxCaveGenerator.runCelluarAutomata","flixel/addons/tile/FlxCaveGenerator.hx",152,0xd1f97ff2)
            	HX_STACK_ARG(InMatrix,"InMatrix")
            	HX_STACK_ARG(OutMatrix,"OutMatrix")
HXLINE( 153)		HX_VARI( Int,rows) = InMatrix->length;
HXLINE( 154)		HX_VARI( Int,columns) = InMatrix->__get((int)0).StaticCast< ::Array< Int > >()->length;
HXLINE( 156)		{
HXLINE( 156)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 156)			while((_g1 < rows)){
HXLINE( 156)				HX_VARI( Int,y) = _g1++;
HXLINE( 158)				{
HXLINE( 158)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 158)					while((_g3 < columns)){
HXLINE( 158)						HX_VARI( Int,x) = _g3++;
HXLINE( 162)						if ((::flixel::addons::tile::FlxCaveGenerator_obj::countNumWallsNeighbors(InMatrix,x,y,(int)1) >= (int)5)) {
HXLINE( 164)							::Array< Int > _hx_tmp = OutMatrix->__get(y).StaticCast< ::Array< Int > >();
HXDLIN( 164)							_hx_tmp[x] = (int)1;
            						}
            						else {
HXLINE( 168)							::Array< Int > _hx_tmp1 = OutMatrix->__get(y).StaticCast< ::Array< Int > >();
HXDLIN( 168)							_hx_tmp1[x] = (int)0;
            						}
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxCaveGenerator_obj,runCelluarAutomata,(void))


FlxCaveGenerator_obj::FlxCaveGenerator_obj()
{
}

bool FlxCaveGenerator_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 18:
		if (HX_FIELD_EQ(inName,"generateCaveMatrix") ) { outValue = generateCaveMatrix_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"generateCaveString") ) { outValue = generateCaveString_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"runCelluarAutomata") ) { outValue = runCelluarAutomata_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"convertMatrixToString") ) { outValue = convertMatrixToString_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"generateInitialMatrix") ) { outValue = generateInitialMatrix_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"countNumWallsNeighbors") ) { outValue = countNumWallsNeighbors_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxCaveGenerator_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *FlxCaveGenerator_obj_sStaticStorageInfo = 0;
#endif

static void FlxCaveGenerator_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxCaveGenerator_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxCaveGenerator_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxCaveGenerator_obj::__mClass,"__mClass");
};

#endif

hx::Class FlxCaveGenerator_obj::__mClass;

static ::String FlxCaveGenerator_obj_sStaticFields[] = {
	HX_HCSTRING("convertMatrixToString","\x60","\x61","\xf3","\x1b"),
	HX_HCSTRING("generateCaveMatrix","\x03","\x9b","\x86","\x26"),
	HX_HCSTRING("generateCaveString","\x93","\x8d","\xee","\x7b"),
	HX_HCSTRING("generateInitialMatrix","\x70","\xc9","\x99","\xb6"),
	HX_HCSTRING("countNumWallsNeighbors","\xef","\x28","\x1d","\xe8"),
	HX_HCSTRING("runCelluarAutomata","\x09","\xde","\x88","\x62"),
	::String(null())
};

void FlxCaveGenerator_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.addons.tile.FlxCaveGenerator","\x6b","\xce","\x1c","\x77");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxCaveGenerator_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FlxCaveGenerator_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxCaveGenerator_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< FlxCaveGenerator_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxCaveGenerator_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxCaveGenerator_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxCaveGenerator_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace addons
} // end namespace tile
