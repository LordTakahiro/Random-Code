// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_Inventory
#include <Inventory.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxExtendedSprite
#include <flixel/addons/display/FlxExtendedSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxButton
#include <flixel/ui/FlxButton.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxTypedButton_flixel_text_FlxText
#include <flixel/ui/FlxTypedButton_flixel_text_FlxText.h>
#endif
#ifndef INCLUDED_flixel_ui__FlxButton_FlxButtonEvent
#include <flixel/ui/_FlxButton/FlxButtonEvent.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSpriteUtil
#include <flixel/util/FlxSpriteUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif


void Inventory_obj::__construct(::cpp::VirtualArray equipment){
            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_0, ::Dynamic,f) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("Inventory","new",0x5d57e56e,"Inventory.new","Inventory.hx",37,0xbb8a21c2)
HXLINE(  37)			f((int)0);
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_1, ::Dynamic,f1) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("Inventory","new",0x5d57e56e,"Inventory.new","Inventory.hx",38,0xbb8a21c2)
HXLINE(  38)			f1((int)0);
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_2, ::Dynamic,f2) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("Inventory","new",0x5d57e56e,"Inventory.new","Inventory.hx",39,0xbb8a21c2)
HXLINE(  39)			f2((int)0);
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_3, ::Dynamic,f3) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("Inventory","new",0x5d57e56e,"Inventory.new","Inventory.hx",43,0xbb8a21c2)
HXLINE(  43)			f3((int)1);
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_4, ::Dynamic,f4) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("Inventory","new",0x5d57e56e,"Inventory.new","Inventory.hx",44,0xbb8a21c2)
HXLINE(  44)			f4((int)1);
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_5, ::Dynamic,f5) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("Inventory","new",0x5d57e56e,"Inventory.new","Inventory.hx",45,0xbb8a21c2)
HXLINE(  45)			f5((int)1);
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_6) HXARGC(1)
            		void _hx_run( ::flixel::FlxSprite spr){
            			HX_STACK_FRAME("Inventory","new",0x5d57e56e,"Inventory.new","Inventory.hx",53,0xbb8a21c2)
            			HX_STACK_ARG(spr,"spr")
HXLINE(  53)			spr->scrollFactor->set((int)0,(int)0);
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_STACK_FRAME("Inventory","new",0x5d57e56e,"Inventory.new","Inventory.hx",29,0xbb8a21c2)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(equipment,"equipment")
HXLINE(  30)		super::__construct(null());
HXLINE(  31)		this->_sprBack =  ::flixel::FlxSprite_obj::__new(null(),null(),null())->makeGraphic((int)320,(int)240,(int)-16777216,null(),null());
HXLINE(  32)		::flixel::util::FlxSpriteUtil_obj::drawRect(this->_sprBack,(int)0,(int)175,(int)320,(int)1,(int)-1,null(),null());
HXLINE(  33)		::flixel::util::FlxSpriteUtil_obj::drawRect(this->_sprBack,(int)130,(int)0,(int)1,(int)175,(int)-1,null(),null());
HXLINE(  35)		this->_btnLeft =  ::flixel::ui::FlxButton_obj::__new((int)15,((Float)192.5),HX_("",00,00,00,00),this->invButton_dyn());
HXLINE(  36)		this->_btnLeft->loadGraphic(HX_("assets/images/arrowLeft.png",20,f5,87,d4),null(),null(),null(),null(),null());
HXLINE(  37)		 ::Dynamic f = this->onOver_dyn();
HXDLIN(  37)		 ::Dynamic _hx_tmp =  ::Dynamic(new _hx_Closure_0(f));
HXDLIN(  37)		this->_btnLeft->onOver->callback = _hx_tmp;
HXLINE(  38)		 ::Dynamic f1 = this->onDown_dyn();
HXDLIN(  38)		 ::Dynamic _hx_tmp1 =  ::Dynamic(new _hx_Closure_1(f1));
HXDLIN(  38)		this->_btnLeft->onDown->callback = _hx_tmp1;
HXLINE(  39)		 ::Dynamic f2 = this->onOut_dyn();
HXDLIN(  39)		 ::Dynamic _hx_tmp2 =  ::Dynamic(new _hx_Closure_2(f2));
HXDLIN(  39)		this->_btnLeft->onOut->callback = _hx_tmp2;
HXLINE(  41)		this->_btnRight =  ::flixel::ui::FlxButton_obj::__new((int)275,((Float)192.5),HX_("",00,00,00,00),this->invButton_dyn());
HXLINE(  42)		this->_btnRight->loadGraphic(HX_("assets/images/arrowRight.png",f9,f8,9b,78),null(),null(),null(),null(),null());
HXLINE(  43)		 ::Dynamic f3 = this->onOver_dyn();
HXDLIN(  43)		 ::Dynamic _hx_tmp3 =  ::Dynamic(new _hx_Closure_3(f3));
HXDLIN(  43)		this->_btnRight->onOver->callback = _hx_tmp3;
HXLINE(  44)		 ::Dynamic f4 = this->onDown_dyn();
HXDLIN(  44)		 ::Dynamic _hx_tmp4 =  ::Dynamic(new _hx_Closure_4(f4));
HXDLIN(  44)		this->_btnRight->onDown->callback = _hx_tmp4;
HXLINE(  45)		 ::Dynamic f5 = this->onOut_dyn();
HXDLIN(  45)		 ::Dynamic _hx_tmp5 =  ::Dynamic(new _hx_Closure_5(f5));
HXDLIN(  45)		this->_btnRight->onOut->callback = _hx_tmp5;
HXLINE(  47)		this->add(this->_sprBack);
HXLINE(  48)		this->add(this->_btnLeft);
HXLINE(  49)		this->add(this->_btnRight);
HXLINE(  50)		this->createSlots();
HXLINE(  51)		this->forEach( ::Dynamic(new _hx_Closure_6()),null());
            	}

Dynamic Inventory_obj::__CreateEmpty() { return new Inventory_obj; }

hx::ObjectPtr< Inventory_obj > Inventory_obj::__new(::cpp::VirtualArray equipment)
{
	hx::ObjectPtr< Inventory_obj > _hx_result = new Inventory_obj();
	_hx_result->__construct(equipment);
	return _hx_result;
}

Dynamic Inventory_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Inventory_obj > _hx_result = new Inventory_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

void Inventory_obj::createSlots(){
            	HX_STACK_FRAME("Inventory","createSlots",0x001c6b27,"Inventory.createSlots","Inventory.hx",57,0xbb8a21c2)
            	HX_STACK_THIS(this)
HXLINE(  58)		HX_VARI( Int,i) = (int)0;
HXLINE(  59)		HX_VARI( Float,tempX) = (int)0;
HXLINE(  60)		while((i < ::Inventory_obj::MAX_SLOTS)){
HXLINE(  61)			this->_sprSlot =  ::flixel::addons::display::FlxExtendedSprite_obj::__new(null(),null(),null());
HXLINE(  62)			this->_sprSlot->loadGraphic(HX_("assets/images/invSlot.png",7f,d6,18,c8),null(),null(),null(),null(),null());
HXLINE(  63)			this->add(this->_sprSlot);
HXLINE(  64)			if ((i == (int)0)) {
HXLINE(  65)				this->_sprSlot->set_x((int)45);
HXLINE(  66)				tempX = this->_sprSlot->x;
HXLINE(  67)				this->_sprSlot->setGraphicSize((int)32,(int)32);
HXLINE(  68)				this->_sprSlot->set_y((int)174);
            			}
            			else {
HXLINE(  71)				this->_sprSlot->setGraphicSize((int)32,(int)32);
HXLINE(  72)				Float _hx_tmp = (tempX + ::Inventory_obj::MAX_SPACING);
HXDLIN(  72)				this->_sprSlot->set_x(_hx_tmp);
HXLINE(  73)				tempX = this->_sprSlot->x;
HXLINE(  74)				this->_sprSlot->set_y((int)174);
            			}
HXLINE(  76)			this->slotArry->insert(i,this->_sprSlot);
HXLINE(  77)			++i;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Inventory_obj,createSlots,(void))

void Inventory_obj::onOver(Int e){
            	HX_STACK_FRAME("Inventory","onOver",0x747aa1c5,"Inventory.onOver","Inventory.hx",82,0xbb8a21c2)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(e,"e")
HXLINE(  82)		switch((int)(e)){
            			case (int)0: {
HXLINE(  83)				this->_btnLeft->loadGraphic(HX_("assets/images/arrowLeftOver.png",14,d3,e9,f0),null(),null(),null(),null(),null());
            			}
            			break;
            			case (int)1: {
HXLINE(  84)				this->_btnRight->loadGraphic(HX_("assets/images/arrowRightOver.png",6d,37,af,54),null(),null(),null(),null(),null());
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Inventory_obj,onOver,(void))

void Inventory_obj::onDown(Int e){
            	HX_STACK_FRAME("Inventory","onDown",0x6d3008d3,"Inventory.onDown","Inventory.hx",89,0xbb8a21c2)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(e,"e")
HXLINE(  89)		switch((int)(e)){
            			case (int)0: {
HXLINE(  90)				this->_btnLeft->loadGraphic(HX_("assets/images/arrowLeftDown.png",22,d9,7a,3d),null(),null(),null(),null(),null());
            			}
            			break;
            			case (int)1: {
HXLINE(  91)				this->_btnRight->loadGraphic(HX_("assets/images/arrowRightDown.png",7b,3d,40,a1),null(),null(),null(),null(),null());
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Inventory_obj,onDown,(void))

void Inventory_obj::onOut(Int e){
            	HX_STACK_FRAME("Inventory","onOut",0xe86a293d,"Inventory.onOut","Inventory.hx",96,0xbb8a21c2)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(e,"e")
HXLINE(  96)		switch((int)(e)){
            			case (int)0: {
HXLINE(  97)				this->_btnLeft->loadGraphic(HX_("assets/images/arrowLeft.png",20,f5,87,d4),null(),null(),null(),null(),null());
            			}
            			break;
            			case (int)1: {
HXLINE(  98)				this->_btnRight->loadGraphic(HX_("assets/images/arrowRight.png",f9,f8,9b,78),null(),null(),null(),null(),null());
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Inventory_obj,onOut,(void))

void Inventory_obj::invButton(){
            	HX_STACK_FRAME("Inventory","invButton",0xd2f90151,"Inventory.invButton","Inventory.hx",102,0xbb8a21c2)
            	HX_STACK_THIS(this)
            	}


HX_DEFINE_DYNAMIC_FUNC0(Inventory_obj,invButton,(void))

void Inventory_obj::updateItems(::cpp::VirtualArray equipment){
            	HX_STACK_FRAME("Inventory","updateItems",0xff79e845,"Inventory.updateItems","Inventory.hx",106,0xbb8a21c2)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(equipment,"equipment")
            	}


HX_DEFINE_DYNAMIC_FUNC1(Inventory_obj,updateItems,(void))

void Inventory_obj::addItem( ::flixel::FlxObject item){
            	HX_STACK_FRAME("Inventory","addItem",0x2acbbbe2,"Inventory.addItem","Inventory.hx",110,0xbb8a21c2)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(item,"item")
            	}


HX_DEFINE_DYNAMIC_FUNC1(Inventory_obj,addItem,(void))

void Inventory_obj::removeItem( ::flixel::FlxObject item){
            	HX_STACK_FRAME("Inventory","removeItem",0x1279c829,"Inventory.removeItem","Inventory.hx",114,0xbb8a21c2)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(item,"item")
            	}


HX_DEFINE_DYNAMIC_FUNC1(Inventory_obj,removeItem,(void))

Int Inventory_obj::MAX_SLOTS;

Int Inventory_obj::MAX_SPACING;


Inventory_obj::Inventory_obj()
{
}

void Inventory_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Inventory);
	HX_MARK_MEMBER_NAME(_sprSlot,"_sprSlot");
	HX_MARK_MEMBER_NAME(_sprBack,"_sprBack");
	HX_MARK_MEMBER_NAME(_btnLeft,"_btnLeft");
	HX_MARK_MEMBER_NAME(_btnRight,"_btnRight");
	HX_MARK_MEMBER_NAME(slotArry,"slotArry");
	 ::flixel::group::FlxTypedGroup_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Inventory_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_sprSlot,"_sprSlot");
	HX_VISIT_MEMBER_NAME(_sprBack,"_sprBack");
	HX_VISIT_MEMBER_NAME(_btnLeft,"_btnLeft");
	HX_VISIT_MEMBER_NAME(_btnRight,"_btnRight");
	HX_VISIT_MEMBER_NAME(slotArry,"slotArry");
	 ::flixel::group::FlxTypedGroup_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Inventory_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"onOut") ) { return hx::Val( onOut_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"onOver") ) { return hx::Val( onOver_dyn()); }
		if (HX_FIELD_EQ(inName,"onDown") ) { return hx::Val( onDown_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"addItem") ) { return hx::Val( addItem_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_sprSlot") ) { return hx::Val( _sprSlot); }
		if (HX_FIELD_EQ(inName,"_sprBack") ) { return hx::Val( _sprBack); }
		if (HX_FIELD_EQ(inName,"_btnLeft") ) { return hx::Val( _btnLeft); }
		if (HX_FIELD_EQ(inName,"slotArry") ) { return hx::Val( slotArry); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_btnRight") ) { return hx::Val( _btnRight); }
		if (HX_FIELD_EQ(inName,"invButton") ) { return hx::Val( invButton_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"removeItem") ) { return hx::Val( removeItem_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"createSlots") ) { return hx::Val( createSlots_dyn()); }
		if (HX_FIELD_EQ(inName,"updateItems") ) { return hx::Val( updateItems_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

bool Inventory_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"MAX_SLOTS") ) { outValue = MAX_SLOTS; return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"MAX_SPACING") ) { outValue = MAX_SPACING; return true; }
	}
	return false;
}

hx::Val Inventory_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"_sprSlot") ) { _sprSlot=inValue.Cast<  ::flixel::addons::display::FlxExtendedSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_sprBack") ) { _sprBack=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_btnLeft") ) { _btnLeft=inValue.Cast<  ::flixel::ui::FlxButton >(); return inValue; }
		if (HX_FIELD_EQ(inName,"slotArry") ) { slotArry=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_btnRight") ) { _btnRight=inValue.Cast<  ::flixel::ui::FlxButton >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Inventory_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"MAX_SLOTS") ) { MAX_SLOTS=ioValue.Cast< Int >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"MAX_SPACING") ) { MAX_SPACING=ioValue.Cast< Int >(); return true; }
	}
	return false;
}

void Inventory_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("_sprSlot","\x54","\x47","\xb2","\x8a"));
	outFields->push(HX_HCSTRING("_sprBack","\x7d","\x43","\x6d","\x7f"));
	outFields->push(HX_HCSTRING("_btnLeft","\x04","\xae","\xf2","\x0e"));
	outFields->push(HX_HCSTRING("_btnRight","\x3f","\xa3","\x72","\x7c"));
	outFields->push(HX_HCSTRING("slotArry","\x16","\x78","\x1d","\x94"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Inventory_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::flixel::addons::display::FlxExtendedSprite*/ ,(int)offsetof(Inventory_obj,_sprSlot),HX_HCSTRING("_sprSlot","\x54","\x47","\xb2","\x8a")},
	{hx::fsObject /*::flixel::FlxSprite*/ ,(int)offsetof(Inventory_obj,_sprBack),HX_HCSTRING("_sprBack","\x7d","\x43","\x6d","\x7f")},
	{hx::fsObject /*::flixel::ui::FlxButton*/ ,(int)offsetof(Inventory_obj,_btnLeft),HX_HCSTRING("_btnLeft","\x04","\xae","\xf2","\x0e")},
	{hx::fsObject /*::flixel::ui::FlxButton*/ ,(int)offsetof(Inventory_obj,_btnRight),HX_HCSTRING("_btnRight","\x3f","\xa3","\x72","\x7c")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Inventory_obj,slotArry),HX_HCSTRING("slotArry","\x16","\x78","\x1d","\x94")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Inventory_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Inventory_obj::MAX_SLOTS,HX_HCSTRING("MAX_SLOTS","\x5a","\x41","\x6e","\x3c")},
	{hx::fsInt,(void *) &Inventory_obj::MAX_SPACING,HX_HCSTRING("MAX_SPACING","\x68","\x2b","\x12","\x64")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Inventory_obj_sMemberFields[] = {
	HX_HCSTRING("_sprSlot","\x54","\x47","\xb2","\x8a"),
	HX_HCSTRING("_sprBack","\x7d","\x43","\x6d","\x7f"),
	HX_HCSTRING("_btnLeft","\x04","\xae","\xf2","\x0e"),
	HX_HCSTRING("_btnRight","\x3f","\xa3","\x72","\x7c"),
	HX_HCSTRING("slotArry","\x16","\x78","\x1d","\x94"),
	HX_HCSTRING("createSlots","\x19","\x98","\x47","\xa8"),
	HX_HCSTRING("onOver","\x13","\x9a","\x42","\xec"),
	HX_HCSTRING("onDown","\x21","\x01","\xf8","\xe4"),
	HX_HCSTRING("onOut","\xaf","\x34","\x6c","\x32"),
	HX_HCSTRING("invButton","\xc3","\xad","\x0a","\x52"),
	HX_HCSTRING("updateItems","\x37","\x15","\xa5","\xa7"),
	HX_HCSTRING("addItem","\xd4","\x07","\xfd","\x81"),
	HX_HCSTRING("removeItem","\x77","\xff","\xde","\xc2"),
	::String(null()) };

static void Inventory_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Inventory_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Inventory_obj::MAX_SLOTS,"MAX_SLOTS");
	HX_MARK_MEMBER_NAME(Inventory_obj::MAX_SPACING,"MAX_SPACING");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Inventory_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Inventory_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Inventory_obj::MAX_SLOTS,"MAX_SLOTS");
	HX_VISIT_MEMBER_NAME(Inventory_obj::MAX_SPACING,"MAX_SPACING");
};

#endif

hx::Class Inventory_obj::__mClass;

static ::String Inventory_obj_sStaticFields[] = {
	HX_HCSTRING("MAX_SLOTS","\x5a","\x41","\x6e","\x3c"),
	HX_HCSTRING("MAX_SPACING","\x68","\x2b","\x12","\x64"),
	::String(null())
};

void Inventory_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("Inventory","\x7c","\x56","\x89","\xea");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Inventory_obj::__GetStatic;
	__mClass->mSetStaticField = &Inventory_obj::__SetStatic;
	__mClass->mMarkFunc = Inventory_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Inventory_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Inventory_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Inventory_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Inventory_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Inventory_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Inventory_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Inventory_obj::__boot()
{
{
            	HX_STACK_FRAME("Inventory","boot",0x47a9db64,"Inventory.boot","Inventory.hx",21,0xbb8a21c2)
HXLINE(  21)		MAX_SLOTS = (int)6;
            	}
{
            	HX_STACK_FRAME("Inventory","boot",0x47a9db64,"Inventory.boot","Inventory.hx",22,0xbb8a21c2)
HXLINE(  22)		MAX_SPACING = (int)34;
            	}
}

